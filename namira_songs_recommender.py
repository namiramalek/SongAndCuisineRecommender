# -*- coding: utf-8 -*-
"""namira_songs_recommender.py.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oa3Rj5YvqTvJ5zAocbppwuAT_mwCDVD_
"""

import pandas as pd
import gzip
import numpy as np

def parse(path):
  g = gzip.open(path, 'rb')
  for l in g:
    yield eval(l)

def getDF(path):
  i = 0
  df = {}
  for d in parse(path):
    df[i] = d
    i += 1
  return pd.DataFrame.from_dict(df, orient='index')

df = getDF('/content/meta_Digital_Music.json.gz')

df.head()

total_instance= len(df)
print("total number of instances of recipes: ",total_instance)

print("--------Null values---------")
print(df.isna().sum())

df = df.drop_duplicates(['title'],keep = 'first')
df.head()

df['description'] = [','.join(map(str, df_list)) for df_list in df['description']]

total_instance= len(df)
print("total number of instances of recipes: ",total_instance)

#column needed
new_df = df[["title", "description"]]

new_df.head()

new_df = new_df.drop_duplicates(['description'],keep = 'first')
new_df.head()

new_df.drop(new_df[new_df['description'] == ''].index, inplace=True)

new_df.head()

new_df['description'][9]

new_df.drop(new_df[new_df['description'] == '.'].index, inplace=True)

new_df.head()

"""Create TF-IDF vectors for the textual description (or overview) of every song"""

from sklearn.feature_extraction.text import TfidfVectorizer

tfidf = TfidfVectorizer(stop_words='english')

tfidf_matrix = tfidf.fit_transform(new_df['description'])

tfidf_matrix.shape

from sklearn.metrics.pairwise import linear_kernel

"""Compute the pairwise cosine similarity score of every song title."""

cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)
type(cosine_sim)
print(cosine_sim[1,1])

"""Store the recommendations into a separate file that your simple app will access"""

indices = pd.Series(new_df.index, index=new_df['title']).drop_duplicates(inplace=False)

indices

# Function that takes in movie title as input and outputs most similar movies
def content_recommender(title, cosine_sim=cosine_sim):
    # Get the index of the movie that matches the title
    idx = indices[title]

    # Get the pairwsie similarity scores of all movies with that movie
    sim_scores = list(enumerate(cosine_sim[idx]))
        
    # Sort the movies based on the similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the scores of the 10 most similar movies
    sim_scores = sim_scores[1:11]

    # Get the movie indices
    music_indices = [i[0] for i in sim_scores]

    # Return the top 10 most similar movies
    return new_df['title'].iloc[music_indices]

def myApp():
 while (True):
  song = input("Enter song name: ")
  
  if song.lower() == "exit":
            break
  
  if (song not in indices):
    print(f"We donâ€™t have recommendations for {song}")
  else:
    print("The top-10 most similar song titles for you: ")
    print(content_recommender(song))

myApp()